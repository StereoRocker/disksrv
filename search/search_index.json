{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for disksrv disksrv is a suite of tools, to read & write hard/floppy disks on a DOS machine, over a TCP/IP based network. Its intended use case is to manage storage media for these machines, without the need to purchase additional hardware to read/write these storage mediums. Please see the GitHub repository for source code and downloads. Getting started This getting started guide will assume you already have a DOS machine, with a packet driver loaded, and a Windows based machine as a client. Copy disksrv.exe to your DOS machine, and run it from DOS. Launch disksrv-client.exe on your Windows machine. Connect to the DOS machine by hostname or IP address. Use the GUI to read a floppy disk, to validate the connection is working as intended. This may take several minutes on real hardware. Download Please see the releases on GitHub . License disksrv is licensed under the GNU Public License, version 3. You may read the full license here .","title":"Home"},{"location":"#documentation-for-disksrv","text":"disksrv is a suite of tools, to read & write hard/floppy disks on a DOS machine, over a TCP/IP based network. Its intended use case is to manage storage media for these machines, without the need to purchase additional hardware to read/write these storage mediums. Please see the GitHub repository for source code and downloads.","title":"Documentation for disksrv"},{"location":"#getting-started","text":"This getting started guide will assume you already have a DOS machine, with a packet driver loaded, and a Windows based machine as a client. Copy disksrv.exe to your DOS machine, and run it from DOS. Launch disksrv-client.exe on your Windows machine. Connect to the DOS machine by hostname or IP address. Use the GUI to read a floppy disk, to validate the connection is working as intended. This may take several minutes on real hardware.","title":"Getting started"},{"location":"#download","text":"Please see the releases on GitHub .","title":"Download"},{"location":"#license","text":"disksrv is licensed under the GNU Public License, version 3. You may read the full license here .","title":"License"},{"location":"client/","text":"disksrv - Client Requirements A .Net 4.0 environment, capable of running WinForms based programs. This should include recent installations of Mono. A TCP/IP network Network access to the disksrv host. Limitations The client currently only supports connecting to one server at a time. Usage Extract the client to a directory, somewhere on your filesystem. Run the disksrv-client.exe file, and the GUI will launch. First you must connect to your disksrv host, you can specify either an IP address or a hostname.","title":"Client"},{"location":"client/#disksrv-client","text":"","title":"disksrv - Client"},{"location":"client/#requirements","text":"A .Net 4.0 environment, capable of running WinForms based programs. This should include recent installations of Mono. A TCP/IP network Network access to the disksrv host.","title":"Requirements"},{"location":"client/#limitations","text":"The client currently only supports connecting to one server at a time.","title":"Limitations"},{"location":"client/#usage","text":"Extract the client to a directory, somewhere on your filesystem. Run the disksrv-client.exe file, and the GUI will launch. First you must connect to your disksrv host, you can specify either an IP address or a hostname.","title":"Usage"},{"location":"protocol/","text":"Network protocol Changelog v1.0 - Initial release Packet structure This protocol works on a system of requests and responses. The client will send a request to the server, with an amount of data. The server will then send a response to the client, with an amount of data. The structure of a request and response packet, are actually identical. The only difference, is the meaning of the first byte. The first byte, for a request, is the command number. For a response, this is the returned status for the request. typedef struct { uint8_t reqstat; // Request number, or response status uint16_t datalen; // Length of the data being sent with this request/response uint8_t data[]; } packet_t; Initial connection Upon initial connection, the server will send 4 bytes. The first two are a magic number, 0x64 0x73 ('DS' in hex). The third byte signifies the major version of the program, and the fourth signifies the minor version. Minor revisions will be protocol-compatible. Major revisions may not be. CHS datatype The CHS datatype is used often in requests/responses. It is defined as 4 bytes. The first byte is the number of sectors per track. The second byte is the number of sides. The next 2 bytes are a 16bit integer, sent in network byte order, signifying the number of tracks. Note: Number of (sectors/sides/tracks) can be interchanged for the desired (sector/side/track) value, in the case of reading/writing to a disk. The BIOS expects side and track to be indexed from 0, and sector to be indexed from 1. Responses reqstat = 0 for failure, or 1 for success. All other values are reserved. Requests There are currently 7 requests defined, their codes and functionality are as below. REQ 0 - QUIT This request should contain no data, and should be sent before closing the TCP connection. The server will then allow another connection. The server will not send a response packet to this, and is the only request to do so. REQ 1 - GET DISK COUNT This request should contain no data. The response should be 2 bytes in length. The first byte is equal to the number of floppy disks present, and the second byte is equal to the number of hard disks present. REQ 2 - GET HARD DISK INFO This request should contain 1 byte of data. This byte is equal to the drive number that is to be queried for information. The drive number should be indexed from 0, and should be less than the value returned from REQ 1. The response will be 4 bytes, containing a CHS datatype. The values returned in the CHS will be total counts. REQ 3 - READ DISK SECTOR This request should contain 5 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The disk number should be 0x00 for the 1st floppy, 0x01 for the 2nd floppy, 0x80 for the 1st hard drive, 0x81 for the 2nd hard drive... This is the value that will be passed to the BIOS. The response will be 512 bytes, if successful, containing the sector data requested. There is nothing in the protocol to stop you from trying to read beyond the length of whatever disk drive is installed. If the BIOS fails reading, however, this command will fail as well. REQ 4 - WRITE DISK SECTOR This request should contain 517 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The next 512 bytes will be the bytes to write to the sector. The disk number should be 0x00 for the 1st floppy, 0x01 for the 2nd floppy, 0x80 for the 1st hard drive, 0x81 for the 2nd hard drive... This is the value that will be passed to the BIOS. The response will contain no data. There is nothing in the protocol to stop you from trying to write beyond the length of whatever disk drive is installed. If the BIOS fails writing, however, this command will fail as well. REQ 5 - GET MAX DISK BUFFER SIZE This request should contain no data. The response should be 2 bytes, interpreted as a 16 bit integer, sent in network byte order. The response is equal to the maximum size of the disk buffer, and is the largest number of bytes that may be read/written to/from a drive using the READ/WRITE MULTIPLE DISK SECTORS commands. Divide this number by 512 to obtain the maximum number of sectors you may request. REQ 6 - READ MULTIPLE DISK SECTORS This request should contain 6 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The last byte should contain the number of sectors to be read. The response will be (sector count * 512 bytes), containing the sector data requested. There is nothing in the protocol to stop you from trying to read beyond the length of whatever disk drive is installed. If the BIOS fails reading, however, this command will fail as well. REQ 7 - WRITE MULTIPLE DISK SECTORS This request should contain 6 + (sector count * 512) bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The next byte is equal to the number of sectors to be written. The next (sector count * 512) bytes will be the bytes to write to the sectors. There is nothing in the protocol to stop you from trying to write beyond the length of whatever disk drive is installed. If the BIOS fails writing, however, this command will fail as well.","title":"Network protocol"},{"location":"protocol/#network-protocol","text":"","title":"Network protocol"},{"location":"protocol/#changelog","text":"v1.0 - Initial release","title":"Changelog"},{"location":"protocol/#packet-structure","text":"This protocol works on a system of requests and responses. The client will send a request to the server, with an amount of data. The server will then send a response to the client, with an amount of data. The structure of a request and response packet, are actually identical. The only difference, is the meaning of the first byte. The first byte, for a request, is the command number. For a response, this is the returned status for the request. typedef struct { uint8_t reqstat; // Request number, or response status uint16_t datalen; // Length of the data being sent with this request/response uint8_t data[]; } packet_t;","title":"Packet structure"},{"location":"protocol/#initial-connection","text":"Upon initial connection, the server will send 4 bytes. The first two are a magic number, 0x64 0x73 ('DS' in hex). The third byte signifies the major version of the program, and the fourth signifies the minor version. Minor revisions will be protocol-compatible. Major revisions may not be.","title":"Initial connection"},{"location":"protocol/#chs-datatype","text":"The CHS datatype is used often in requests/responses. It is defined as 4 bytes. The first byte is the number of sectors per track. The second byte is the number of sides. The next 2 bytes are a 16bit integer, sent in network byte order, signifying the number of tracks. Note: Number of (sectors/sides/tracks) can be interchanged for the desired (sector/side/track) value, in the case of reading/writing to a disk. The BIOS expects side and track to be indexed from 0, and sector to be indexed from 1.","title":"CHS datatype"},{"location":"protocol/#responses","text":"reqstat = 0 for failure, or 1 for success. All other values are reserved.","title":"Responses"},{"location":"protocol/#requests","text":"There are currently 7 requests defined, their codes and functionality are as below.","title":"Requests"},{"location":"protocol/#req-0-quit","text":"This request should contain no data, and should be sent before closing the TCP connection. The server will then allow another connection. The server will not send a response packet to this, and is the only request to do so.","title":"REQ 0 - QUIT"},{"location":"protocol/#req-1-get-disk-count","text":"This request should contain no data. The response should be 2 bytes in length. The first byte is equal to the number of floppy disks present, and the second byte is equal to the number of hard disks present.","title":"REQ 1 - GET DISK COUNT"},{"location":"protocol/#req-2-get-hard-disk-info","text":"This request should contain 1 byte of data. This byte is equal to the drive number that is to be queried for information. The drive number should be indexed from 0, and should be less than the value returned from REQ 1. The response will be 4 bytes, containing a CHS datatype. The values returned in the CHS will be total counts.","title":"REQ 2 - GET HARD DISK INFO"},{"location":"protocol/#req-3-read-disk-sector","text":"This request should contain 5 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The disk number should be 0x00 for the 1st floppy, 0x01 for the 2nd floppy, 0x80 for the 1st hard drive, 0x81 for the 2nd hard drive... This is the value that will be passed to the BIOS. The response will be 512 bytes, if successful, containing the sector data requested. There is nothing in the protocol to stop you from trying to read beyond the length of whatever disk drive is installed. If the BIOS fails reading, however, this command will fail as well.","title":"REQ 3 - READ DISK SECTOR"},{"location":"protocol/#req-4-write-disk-sector","text":"This request should contain 517 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The next 512 bytes will be the bytes to write to the sector. The disk number should be 0x00 for the 1st floppy, 0x01 for the 2nd floppy, 0x80 for the 1st hard drive, 0x81 for the 2nd hard drive... This is the value that will be passed to the BIOS. The response will contain no data. There is nothing in the protocol to stop you from trying to write beyond the length of whatever disk drive is installed. If the BIOS fails writing, however, this command will fail as well.","title":"REQ 4 - WRITE DISK SECTOR"},{"location":"protocol/#req-5-get-max-disk-buffer-size","text":"This request should contain no data. The response should be 2 bytes, interpreted as a 16 bit integer, sent in network byte order. The response is equal to the maximum size of the disk buffer, and is the largest number of bytes that may be read/written to/from a drive using the READ/WRITE MULTIPLE DISK SECTORS commands. Divide this number by 512 to obtain the maximum number of sectors you may request.","title":"REQ 5 - GET MAX DISK BUFFER SIZE"},{"location":"protocol/#req-6-read-multiple-disk-sectors","text":"This request should contain 6 bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The last byte should contain the number of sectors to be read. The response will be (sector count * 512 bytes), containing the sector data requested. There is nothing in the protocol to stop you from trying to read beyond the length of whatever disk drive is installed. If the BIOS fails reading, however, this command will fail as well.","title":"REQ 6 - READ MULTIPLE DISK SECTORS"},{"location":"protocol/#req-7-write-multiple-disk-sectors","text":"This request should contain 6 + (sector count * 512) bytes of data. The first should contain the disk number. The next 4 should contain a CHS struct. The next byte is equal to the number of sectors to be written. The next (sector count * 512) bytes will be the bytes to write to the sectors. There is nothing in the protocol to stop you from trying to write beyond the length of whatever disk drive is installed. If the BIOS fails writing, however, this command will fail as well.","title":"REQ 7 - WRITE MULTIPLE DISK SECTORS"},{"location":"server/","text":"disksrv - Server Requirements IBM compatible BIOS DOS (only tested in MS-DOS 6.22) A packet driver A TCP/IP network Limitations The disk reading/writing routines in disksrv.exe rely on the BIOS, specifically INT 13h . It does not implement the INT 13h extensions, introduced by IBM/Microsoft in 1992. Usage Just run disksrv.exe - it has no dependencies to other files. Configuration There is none! Watch this space, modifying the disk buffer size is on the roadmap. WATTCP is the library used to provide networking support for disksrv. See this guide on how to configure WATTCP. If disksrv is unable to read a WATTCP configuration file, it will automatically attempt DHCP/BOOTP auto-configuration.","title":"Server"},{"location":"server/#disksrv-server","text":"","title":"disksrv - Server"},{"location":"server/#requirements","text":"IBM compatible BIOS DOS (only tested in MS-DOS 6.22) A packet driver A TCP/IP network","title":"Requirements"},{"location":"server/#limitations","text":"The disk reading/writing routines in disksrv.exe rely on the BIOS, specifically INT 13h . It does not implement the INT 13h extensions, introduced by IBM/Microsoft in 1992.","title":"Limitations"},{"location":"server/#usage","text":"Just run disksrv.exe - it has no dependencies to other files.","title":"Usage"},{"location":"server/#configuration","text":"There is none! Watch this space, modifying the disk buffer size is on the roadmap. WATTCP is the library used to provide networking support for disksrv. See this guide on how to configure WATTCP. If disksrv is unable to read a WATTCP configuration file, it will automatically attempt DHCP/BOOTP auto-configuration.","title":"Configuration"}]}